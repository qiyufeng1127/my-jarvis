# 任务时间自动调整功能说明

## 功能概述

任务卡片的时间会根据你实际启动/完成验证的时间自动调整，且调整后若与原有任务时间冲突，冲突的任务会自动下移到空闲时段，全程保留其他原有逻辑。

## 详细调整逻辑

### 1. 任务卡片启动时间自动修正

**触发条件：**
- 你为某任务（如原计划 6:00 开始）提前或延后操作（如 3:00 点击并通过启动验证）

**调整规则：**
- 该任务卡片会从时间轴上原 6:00 的位置，自动移动到你实际启动验证通过的时间（3:00）
- 任务时长保持不变（如原计划 30 分钟，调整后仍为 30 分钟）
- 新的结束时间 = 实际启动时间 + 任务时长（3:00 + 30分钟 = 3:30）

**示例：**
```
原计划：6:00 - 6:30 (30分钟)
实际启动：3:00
调整后：3:00 - 3:30 (30分钟)
```

### 2. 任务卡片结束时间自动修正

**触发条件：**
- 任务启动后，你提前完成并通过完成验证（如原计划 30 分钟、应 3:30 结束，实际 3:20 完成验证）

**调整规则：**
- 该任务卡片的结束时间会自动更新为实际完成验证的时间（3:20）
- 实际时长 = 实际完成时间 - 实际启动时间（3:20 - 3:00 = 20分钟）
- 提前完成会获得额外金币奖励

**示例：**
```
原计划：3:00 - 3:30 (30分钟)
实际完成：3:20
调整后：3:00 - 3:20 (20分钟)
提前完成：10分钟，获得额外奖励
```

### 3. 时间冲突时的任务自动下移规则

**判定条件：**
- 当你提前启动的任务（如 3:00 启动原 6:00 的任务），导致该时段（3:00）原本已有其他任务

**调整规则：**
1. **优先保留**：你主动启动的任务在实际启动时间（3:00）
2. **自动下移**：原本占用 3:00 时段的任务，会自动向下移动
3. **寻找空闲**：寻找最近的无任务空闲时段（如 3:00-3:30 被占用，则移到 3:30 之后第一个无任务的时间点）
4. **保留属性**：下移过程中仅调整冲突任务的时间，不修改其原本的时长、金币规则等其他属性

**示例场景：**
```
原时间轴：
- 3:00 - 3:30: 任务A（洗碗）
- 6:00 - 6:30: 任务B（工作）

用户在 3:00 启动任务B：
调整后时间轴：
- 3:00 - 3:30: 任务B（工作）← 提前启动
- 3:30 - 4:00: 任务A（洗碗）← 自动下移到最近空闲时段
```

**复杂场景（多个冲突）：**
```
原时间轴：
- 3:00 - 3:30: 任务A
- 3:30 - 4:00: 任务B
- 6:00 - 7:00: 任务C（60分钟）

用户在 3:00 启动任务C：
调整后时间轴：
- 3:00 - 4:00: 任务C（60分钟）← 提前启动
- 4:00 - 4:30: 任务A（30分钟）← 自动下移
- 4:30 - 5:00: 任务B（30分钟）← 自动下移
```

## 技术实现

### 核心工具函数

位置：`src/utils/taskTimeAdjuster.ts`

#### 1. `adjustTaskStartTime(taskId, actualStartTime, allTasks)`
- 调整任务启动时间
- 检测时间冲突
- 自动下移冲突任务
- 返回更新后的任务列表

#### 2. `adjustTaskEndTime(taskId, actualEndTime, allTasks)`
- 调整任务完成时间
- 记录实际时长
- 计算提前完成奖励

#### 3. `findNextAvailableSlot(targetStart, duration, existingTasks, excludeTaskId)`
- 查找最近的空闲时间段
- 避免时间冲突
- 智能排序和查找

### 集成位置

#### 1. NewTimelineView.tsx
- 启动验证成功后调用 `adjustTaskStartTime`
- 完成验证成功后调用 `adjustTaskEndTime`
- 批量更新所有受影响的任务

#### 2. taskStore.ts
- `completeStartVerification` 方法集成时间调整
- `completeTask` 方法集成时间调整
- 确保 store 层面的数据一致性

## 保留的核心规则

### ✅ 保持不变的内容

1. **任务时长**：下移任务的时长保持不变
2. **金币规则**：金币计算逻辑完全保留
3. **验证机制**：启动/完成验证流程不变
4. **奖励系统**：提前完成奖励、超时惩罚等规则不变
5. **任务属性**：标签、描述、优先级等属性不变
6. **其他逻辑**：子任务、图片、笔记等功能不受影响

### 🔧 仅调整的内容

1. **开始时间**：根据实际启动时间调整
2. **结束时间**：根据实际完成时间调整
3. **时间轴位置**：任务在时间轴上的显示位置

## 用户体验

### 优势

1. **灵活性**：可以随时启动任何任务，不受原计划时间限制
2. **自动化**：无需手动调整冲突任务，系统自动处理
3. **准确性**：时间轴始终反映真实的任务执行情况
4. **无缝体验**：调整过程自动完成，用户无感知

### 视觉反馈

- ✅ 启动验证成功后，任务卡片立即移动到新位置
- 📍 冲突任务自动下移，带有平滑动画
- 💰 金币奖励正常发放，不受时间调整影响
- 🎉 庆祝效果正常显示

## 日志输出

系统会在控制台输出详细的调整日志：

```javascript
🔧 调整任务启动时间: {
  taskId: "xxx",
  taskTitle: "工作",
  originalStart: "6:00:00",
  actualStart: "3:00:00",
  newEnd: "3:30:00",
  duration: "30分钟"
}

⚠️ 发现 2 个冲突任务

📍 任务自动下移: 洗碗 {
  原时间: "3:00:00 - 3:30:00",
  新时间: "3:30:00 - 4:00:00"
}

✅ 任务启动验证成功，时间已自动修正，冲突任务已下移
```

## 注意事项

1. **同一天限制**：只处理同一天内的任务冲突
2. **已完成任务**：已完成或已取消的任务不会被下移
3. **时间顺序**：下移后的任务按时间顺序排列
4. **空闲查找**：从冲突任务结束时间开始查找空闲时段
5. **防止循环**：设置最大迭代次数，防止无限循环

## 测试场景

### 场景1：提前启动单个任务
```
原计划：
- 9:00 - 10:00: 任务A
- 14:00 - 15:00: 任务B

操作：在 9:00 启动任务B
结果：
- 9:00 - 10:00: 任务B ← 提前启动
- 10:00 - 11:00: 任务A ← 自动下移
```

### 场景2：提前完成任务
```
原计划：
- 9:00 - 10:00: 任务A (60分钟)

操作：9:00 启动，9:30 完成
结果：
- 9:00 - 9:30: 任务A (30分钟) ← 提前30分钟完成
- 获得额外奖励：50%以上提前，奖励100%金币
```

### 场景3：延后启动任务
```
原计划：
- 9:00 - 10:00: 任务A

操作：在 10:30 启动任务A
结果：
- 10:30 - 11:30: 任务A ← 延后启动
- 可能有超时惩罚（根据验证规则）
```

## 未来优化方向

1. **智能建议**：提示用户最佳启动时间
2. **批量调整**：一次性调整多个任务
3. **撤销功能**：允许撤销时间调整
4. **可视化**：在时间轴上显示调整动画
5. **冲突预警**：启动前提示可能的冲突

## 总结

任务时间自动调整功能让时间轴更加灵活和智能，用户可以随时启动任何任务，系统会自动处理时间冲突，确保时间轴始终准确反映实际情况，同时保留所有原有的金币、验证、奖励等核心逻辑。



